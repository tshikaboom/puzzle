Si (nombre de cartes == 0) //conditionnement
    nombre de solutions ++
    affichage de la solution
    
    x = meilleur position possible de x
    y = meilleur position possible de y
    
    Si plateau[x][y] == nombre de case libre (reste de case)  ET  test de rotation == 4
       return TRUE

    finSI
finSI

Pour carte[0] a nombre de cartes

     Si on a une carte ET le placement est possible
        -place la carte sur le plateau 
        -on enleve la carte de la liste des cartes disponibles
        
        Si appel recursif de backtrack sur la case suivante
           return TRUE
        finSI

        -plateau == -1 , reinitialisation des valeurs fausses
        -on enleve la carte fausse du plateau 
        -reinitialisation de la rotation de la carte
      finSI
finPOUR

return FALSE



/*CHEMIN*/


En Spirale :

int tabI[10] = {1,0,0,1,2,2,2,1,0};
int tabJ[10] = {1,1,2,2,2,1,0,0,0};

En Z :

int tabI[10] = {0,1,2,2,1,0,0,1,2};
int tabJ[10] = {0,0,0,1,1,1,2,2,2};


Position chemin (int i, ,int choix)
{
	Position pos_suivant;
	/*En Spirale*/
	int tabI_spirale[10] = {1,0,0,1,2,2,2,1,0};
	int tabJ_spirale[10] = {1,1,2,2,2,1,0,0,0};
	
	/*En Z*/
	int tabI_Z[10] = {0,1,2,2,1,0,0,1,2};
	int tabJ_Z[10] = {0,0,0,1,1,1,2,2,2};

	
	switch(choix)
	{
		case 1 :
		       pos_suivant.x = tabI_spirale[i+1];
		       pos_suivant.y = tabJ_spirale[i+1];
		       return pos_suivant;
		       break;
		
		case 2 :
		     pos_suivant.x = tabI_Z[i+1];
		     pos_suivant.y = tabJ_Z[i+1];
		     return pos_suivant;
		     break;
       }
}
	



/*Reinitialisation rotation*/

void rotation_0 (Carte defcarte[], int carte) { /* remet la rotation de la carte a 0 */
  while (defcarte[carte].rotation != 0) {
    rotation(defcarte,carte);
  }
}
