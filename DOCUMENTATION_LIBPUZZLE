##=============================================##
##== DOCUMENTATION DE LA BIBLIOTHEQUE PUZZLE ==##
##=============================================##

#define TAILLE 3 -> le cote du plateau carre, on a donc TAILLE*TAILLE cases

#== Structure d'une carte ==#
struct carte {
  int identifiant;      -> L'identifiant de la carte 
  int Haut;             -> valeur se trouvant sur le haut de la carte
  int Bas;              -> valeur du bas de la carte
  int Gauche;           -> valeur de la gauche de la carte
  int Droite;           -> valeur de la droite de la carte
  unsigned int rotated; -> indice de rotation
  
  /* La rotation de la carte varie entre 0 et 4. Les valeurs 0 et 4 sont equivalents,
     la difference etant qu'on sait que la carte a deja effectue une rotation complete
     avec la valeur 4. Des qu'une rotation aura ete effectuee, la carte ne pourra
     plus avoir la valeur 0. (sert pour la fonction rotation)
     La rotation d'une carte signifie qu'elle est tournee dans le sens des aiguilles
     d'une montre. La variable est alors incrementee de 1. */     
  
  unsigned int sur_plateau; -> 0 = pas sur plateau ET 1 = sur plateau 
};

#== Structure de position ==#
struct position {
  int x;
  int y;
};

#== Structure du plateau ==#
struct plateau {
  struct carte ***tab;  -> plateau == tableau a deux dimensions de pointeurs
  int hauteur;          -> hauteur du plateau
  int largeur;          -> largeur du plateau
};

typedef struct carte Carte;
typedef struct position Position;
typedef struct plateau Plateau;

#== structure du chemin, revient a une liste chainee en pratique x et y sont les coordonnees sur le plateau ==#
struct chemin {
    int x;
    int y;
    struct chemin *Suivant;
};

typedef struct coordonnee Coordonnee;
typedef struct chemin Chemin;


#== Algorithme de backtracking ==#
int backtrack (Plateau *plateau,Carte tabCarte[], Chemin *parcours, int nombre_de_carte,int indice_chemin,int choix);

#== teste si la carte est positionnable avec la carte deja posee en haut de (i, j) sur le plateau ==#
int contact_h(Plateau *plateau, int i, int j, Carte Carte);

#== idem pour la droite ==#
int contact_d(Plateau *plateau, int i, int j, Carte Carte);

#== idem pour le bas ==#
int contact_b(Plateau *plateau, int i, int j, Carte Carte);

#== idem pour la gauche ==#
int contact_g(Plateau *plateau, int i, int j, Carte Carte);

#== Teste si la carte est positionnable a la postion donnee. Utilise les 4 fonctions precedemment definies. ==#
int cartePossible(Carte *carte, Plateau *plateau,int i, int j);

#== Fonction determinant la case de depart pour un parcours en spirale ==#
Position caseDepart (int largeur, int hauteur);

#== Suivant => case suivant vide ou non ==#
int suivant (Plateau *plateau, Position courante);

#== Gestion de la rotation: rotation(carte, 1) tourne la carte une fois dans le sens des aiguilles d'une montre ==#
void rotation (Carte *carte,unsigned int nombre);

#== Affichage d'un plateau de taille arbitraire ==#
void affichage (Plateau *plateau);

#== Allocation d'un nouveau plateau de taille largeur*hauteur. La fonction initialise les cases du plateau a NULL. ==#
Plateau *nouveau_plateau(int hauteur, int largeur);

#== Echange la liste de carte. Sert a generer toutes les solutions ==#
void swap (Plateau *plateau,Carte tabCarte[]);

#== Nettoyage du plateau pour la fonction backtrack ==#
void clean_plateau (Plateau *plateau);

#== initialisation d'une liste chainee ==#
Chemin *nouveau_chemin(int x, int y);

#== rajout d'un element dans la liste ==#
Chemin *rajoute_chemin(Chemin *liste, int x, int y);

#== minimum entre deux nombres ==#
int min(int a,int b);

#== valeur absoluee d'un nombre ==#
int abs(int n);

#== accesseur des coordonnees de la premiere cellule de la liste ==#
Position get_pos(Chemin *chemin);

#== affichage minimaliste d'un chemin en (x, y) ==#
void print_chemin(Chemin *chemin);

#== Fonctions creant les chemins pour un plateau de taille arbitraire. Elles retournent une liste avec les coordonnees necessaires ==#
Chemin* constCheminEnS(int n,int p);
Chemin* constCheminSpirale(int n, int p);

#== Checks if input char is EndOfLine ==#
int isEndOfLine (char cara);

#== cara Char to be cast to integer ==#
int charToInteger(char cara);

#== Input string lenght ==#
int strLength(char* str);

#== str Input string to be parsed to integer ==#
int stringToInteger(char* str);

#== char* Error Message ==#
void error(char* errorMessage);

#== Read the card ==#
int readCard(char* stringCard, Carte* current);

#== Carte** an array containing the cards that were parsed from the file ==#
Carte* parseFile(char* filename,int* hauteur,int* largeur);

#== Carte** array of cards containing the cards to be exported ==#
void export(char* filename,int hauteur,int largeur,Carte** stack);
